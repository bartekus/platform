name: Build and Push

on:
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  SERVICES_TO_PUSH: web
  APP_PROFILE: app
  INFRA_PROFILE: infra

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta (tags for all images)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix=,suffix=,format=short

      - name: Compute short SHA
        id: vars
        run: echo "short_sha=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"

      # Build/push non-API services with buildx (web,background)
      - name: Build & push (from docker-compose-deploy.yml with fallbacks)
        env:
          COMPOSE_FILE: docker-compose-deploy.yml
          SHORT_SHA: ${{ steps.vars.outputs.short_sha }}
        shell: python
        run: |
          import os, sys, subprocess, yaml
          
          REGISTRY = os.environ["REGISTRY"]
          IMAGE_NAME = os.environ["IMAGE_NAME"]       # e.g. bartekus/platform
          SERVICES_TO_PUSH = [s.strip() for s in os.environ["SERVICES_TO_PUSH"].split(",") if s.strip()]
          COMPOSE_FILE = os.environ.get("COMPOSE_FILE", "docker-compose.yml")
          SHORT_SHA = os.environ["SHORT_SHA"]
          
          # Conventional fallbacks when compose has no build: blocks
          FALLBACKS = {
            "web":  {"context": "frontend", "dockerfile": "Dockerfile"},
            "api":  {"context": "backend",  "dockerfile": "Dockerfile"},
            # "background": {"context": "background", "dockerfile": "Dockerfile"},
          }
          
          def sh(cmd, **kw):
            print("+", " ".join(cmd))
            subprocess.check_call(cmd, **kw)
          
          # Load compose (if present)
          compose = {}
          if os.path.exists(COMPOSE_FILE):
            with open(COMPOSE_FILE, "r") as f:
              compose = yaml.safe_load(f) or {}
          services_cfg = (compose.get("services") or {}) if isinstance(compose, dict) else {}
          
          for svc in SERVICES_TO_PUSH:
            print(f"==> {svc}")
            # Derive context/dockerfile
            context = None
            dockerfile = None
          
            if svc in services_cfg and isinstance(services_cfg[svc], dict) and "build" in services_cfg[svc]:
              b = services_cfg[svc]["build"]
              if isinstance(b, str):
                context = b
                dockerfile = os.path.join(context, "Dockerfile")
              elif isinstance(b, dict):
                context = b.get("context", ".")
                df = b.get("dockerfile", "Dockerfile")
                dockerfile = df if os.path.isabs(df) else os.path.join(context, df)
          
            # Fallbacks when no build info in compose
            if context is None or dockerfile is None:
              fb = FALLBACKS.get(svc)
              if not fb:
                print(f"Warning: No build info for '{svc}' and no fallback mapping. Skipping.")
                continue
              context = fb["context"]
              dockerfile = os.path.join(context, fb["dockerfile"])
          
            # Validate paths
            if not os.path.isdir(context):
              print(f"Error: context directory not found: {context}", file=sys.stderr)
              sys.exit(1)
            if not os.path.isfile(dockerfile):
              print(f"Error: Dockerfile not found: {dockerfile}", file=sys.stderr)
              sys.exit(1)
          
            repo = f"{REGISTRY}/{IMAGE_NAME}/{svc}"
            latest_tag = f"{repo}:latest"
            sha_tag = f"{repo}:{SHORT_SHA}"
            cache_ref = f"{repo}:buildcache"
          
            cmd = [
              "docker","buildx","build",
              "--file", dockerfile,
              "--tag", latest_tag,
              "--tag", sha_tag,
              "--cache-from", f"type=registry,ref={cache_ref}",
              "--cache-to",   f"type=registry,mode=max,ref={cache_ref}",
              "--push",
              context
            ]
            # Add plain progress if you want verbose output:
            # cmd.insert(5, "--progress=plain")
            sh(cmd)
          
          print("âœ… Done building & pushing:", ", ".join(SERVICES_TO_PUSH))

      # Read encore.dev version from package.json and normalize to "vX.Y.Z"
      - name: Resolve Encore CLI version from package.json
        id: encorever
        run: |
          set -Eeuo pipefail
          RAW=$(jq -r '.dependencies["encore.dev"] // empty' package.json)
          [ -n "$RAW" ] && [ "$RAW" != "null" ] || { echo "encore.dev dep missing"; exit 1; }
          CLEAN=$(printf "%s" "${RAW}" | sed 's/^[^0-9]*//')
          echo "version=v${CLEAN}" >> "$GITHUB_OUTPUT"

      - name: Set up Node (for Encore parser)
        uses: actions/setup-node@v4
        with:
          node-version: '22'                # match your frontend
          cache: 'npm'
          cache-dependency-path: |
            frontend/package-lock.json
            backend/package-lock.json

      - name: Install JS deps needed for parsing
        run: |
          set -Eeuo pipefail
          if [ -f frontend/package-lock.json ]; then
            npm ci --prefix frontend
          fi
          # If your backend has a package.json used by encore.ts runtime, keep this:
          if [ -f backend/package-lock.json ]; then
            npm ci --prefix backend
          fi

      # --- Encore API build & push ---
      - name: Install Encore CLI (pinned from package.json)
        env:
          ENCORE_VERSION: ${{ steps.encorever.outputs.version }}
        run: |
          set -Eeuo pipefail
          curl -fsSL https://encore.dev/install.sh -o install.sh
          bash install.sh
          /home/runner/.encore/bin/encore version

      - name: Verify Encore version
        run: |
          set -Eeuo pipefail
          WANT='${{ steps.encorever.outputs.version }}'
          GOT=$(/home/runner/.encore/bin/encore version | awk '{print $NF}')
          echo "Encore want=${WANT} got=${GOT}"
          test "${WANT}" = "${GOT}"

      - name: Build API image via Encore (from repo root)
        env:
          DOCKER_DEFAULT_PLATFORM: linux/amd64
        run: |
          set -Eeuo pipefail
          test -f ./encore-config.json || { echo "encore-config.json missing at repo root"; exit 1; }
          test -f ./encore.app || { echo "encore.app missing at repo root"; exit 1; }
          /home/runner/.encore/bin/encore build docker \
            --config ./encore-config.json \
            encore-app
          docker image inspect encore-app >/dev/null

      - name: Tag & push API image to GHCR (latest + sha)
        run: |
          set -Eeuo pipefail
          # Prefer our computed short SHA; fall back to first 7 of GITHUB_SHA.
          SHA_TAG="${{ steps.vars.outputs.short_sha }}"
          if [ -z "$SHA_TAG" ]; then
            SHA_TAG="$(echo "${GITHUB_SHA}" | cut -c1-7)"
          fi
          echo "Using SHA_TAG=$SHA_TAG"
          
          docker tag encore-app ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest
          docker tag encore-app ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${SHA_TAG}
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${SHA_TAG}

      - name: Print target host (sanity)
        run: |
          echo "Target host: ${{ vars.HOST }}"
          echo "Target user: ${{ vars.USER }}"

      # --- Materialize deployment artifacts from secrets ---
      - name: Prepare deployment artifacts from secrets
        run: |
          set -Eeuo pipefail
          mkdir -p .deploy/logto

          # 1) .env from ENV_FILE secret (verbatim)
          cat > .deploy/env <<'EOF'
          ${{ secrets.ENV_FILE }}
          EOF
          
          # 2) Postgres init script
          cat > .deploy/pg-init.sh <<'EOF'
          ${{ secrets.PG_INIT_SCRIPT }}
          EOF
          chmod +x .deploy/pg-init.sh
          
          # 3) Logto custom setup files
          cat > .deploy/logto/config.js <<'EOF'
          ${{ secrets.LOGTO_CONFIG }}
          EOF
          
          cat > .deploy/logto/entrypoint.sh <<'EOF'
          ${{ secrets.LOGTO_ENTRYPOINT }}
          EOF
          chmod +x .deploy/logto/entrypoint.sh
          
          cat > .deploy/logto/index.js <<'EOF'
          ${{ secrets.LOGTO_INDEX }}
          EOF
          
          cat > .deploy/logto/setup.js <<'EOF'
          ${{ secrets.LOGTO_SETUP }}
          EOF
          
          ls -lah .deploy .deploy/logto

      - name: Pack deployment bundle
        run: |
          set -Eeuo pipefail
      
          # Sanity: make sure files exist
          for f in \
            .deploy/env \
            .deploy/pg-init.sh \
            .deploy/logto/config.js \
            .deploy/logto/entrypoint.sh \
            .deploy/logto/index.js \
            .deploy/logto/setup.js \
            docker-compose-deploy.yml
          do
            [ -f "$f" ] || { echo "Missing $f"; exit 1; }
          done
      
          # Create a minimal bundle dir to keep paths predictable
          rm -rf .bundle && mkdir -p .bundle/.deploy/logto
          cp -a docker-compose-deploy.yml .bundle/
          cp -a .deploy/env .bundle/.deploy/env
          cp -a .deploy/pg-init.sh .bundle/.deploy/pg-init.sh
          cp -a .deploy/logto/config.js .bundle/.deploy/logto/config.js
          cp -a .deploy/logto/entrypoint.sh .bundle/.deploy/logto/entrypoint.sh
          cp -a .deploy/logto/index.js .bundle/.deploy/logto/index.js
          cp -a .deploy/logto/setup.js .bundle/.deploy/logto/setup.js
          
          tar -czf platform-bundle.tgz -C .bundle .
          ls -lah platform-bundle.tgz

      - name: Copy deployment bundle to remote
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USER }}
          key: ${{ secrets.SSH_KEY }}
          target: "/tmp"
          source: platform-bundle.tgz

      - name: Unpack and place artifacts on remote
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            set -Eeuo pipefail
            
            BUNDLE_TGZ="/tmp/platform-bundle.tgz"
            SRC_DIR="/tmp/platform-bundle"
            sudo rm -rf "$SRC_DIR"
            sudo mkdir -p "$SRC_DIR"
            sudo tar -xzf "$BUNDLE_TGZ" -C "$SRC_DIR"
            
            echo "Bundle contents:"
            sudo find "$SRC_DIR" -maxdepth 3 -type f -ls || true
            
            # Create FHS directories (avoid brace expansion)
            sudo mkdir -p /etc/platform
            sudo mkdir -p /opt/platform/scripts/db/pg-init-scripts
            sudo mkdir -p /opt/platform/scripts/logto
            sudo mkdir -p /opt/platform
            sudo mkdir -p /var/lib/platform/postgres /var/lib/platform/redis /var/lib/platform/letsencrypt
            
            # Validate expected files before moving
            for f in \
              "$SRC_DIR/.deploy/env" \
              "$SRC_DIR/.deploy/pg-init.sh" \
              "$SRC_DIR/.deploy/logto/config.js" \
              "$SRC_DIR/.deploy/logto/entrypoint.sh" \
              "$SRC_DIR/.deploy/logto/index.js" \
              "$SRC_DIR/.deploy/logto/setup.js" \
              "$SRC_DIR/docker-compose-deploy.yml"
            do
              [ -f "$f" ] || { echo "Missing: $f"; exit 1; }
            done
            
            # Move config/env
            sudo mv "$SRC_DIR/.deploy/env" /etc/platform/env
            sudo chown root:root /etc/platform/env
            sudo chmod 600 /etc/platform/env
            
            # Move compose
            sudo mv "$SRC_DIR/docker-compose-deploy.yml" /opt/platform/docker-compose.yml
            sudo chown root:root /opt/platform/docker-compose.yml
            sudo chmod 644 /opt/platform/docker-compose.yml
            
            # PG init script
            sudo mv "$SRC_DIR/.deploy/pg-init.sh" /opt/platform/scripts/db/pg-init.sh
            sudo chown -R root:root /opt/platform/scripts
            sudo chmod +x /opt/platform/scripts/db/pg-init.sh
            
            # Logto custom files
            sudo mv "$SRC_DIR/.deploy/logto/config.js"     /opt/platform/scripts/logto/config.js
            sudo mv "$SRC_DIR/.deploy/logto/entrypoint.sh" /opt/platform/scripts/logto/entrypoint.sh
            sudo mv "$SRC_DIR/.deploy/logto/index.js"      /opt/platform/scripts/logto/index.js
            sudo mv "$SRC_DIR/.deploy/logto/setup.js"      /opt/platform/scripts/logto/setup.js
            sudo chmod 755 /opt/platform/scripts/logto
            sudo chmod 644 /opt/platform/scripts/logto/*.js
            sudo chmod +x  /opt/platform/scripts/logto/entrypoint.sh
            
            echo "âœ… Files placed."

      - name: Deploy with rollout (profiles-aware + immutable tag + draining)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USER }}
          key: ${{ secrets.SSH_KEY }}
          script_stop: true
          script: |
            set -Eeuo pipefail
            cd /opt/platform
            
            # login to GHCR
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
            
            # Resolve immutable tag from workflow (falls back to 7-char GITHUB_SHA)
            SHA_TAG="${{ steps.vars.outputs.short_sha }}"
            if [ -z "$SHA_TAG" ]; then
              SHA_TAG="$(echo "${GITHUB_SHA}" | cut -c1-7)"
            fi

            # Resolve immutable tag from workflow (already set to badd9dc above)
            echo "Using SHA_TAG=$SHA_TAG"
            
            # Pull application images by immutable tag
            SERVICES_CSV="${SERVICES_CSV:-${{ env.SERVICES_TO_PUSH }}}"
            IFS=',' read -ra SERVICES <<< "$SERVICES_CSV"
            for service in "${SERVICES[@]}"; do
              s="$(echo "$service" | xargs)"
              [ -n "$s" ] || continue
              echo "Pulling ghcr.io/${{ env.IMAGE_NAME }}/$s:$SHA_TAG"
              docker pull "ghcr.io/${{ env.IMAGE_NAME }}/$s:$SHA_TAG"
            done
            echo "Pulling ghcr.io/${{ env.IMAGE_NAME }}/api:$SHA_TAG"
            docker pull "ghcr.io/${{ env.IMAGE_NAME }}/api:$SHA_TAG"
            
            # Verify that /etc/platform/env is accessible
            if [ -f /etc/platform/env ]; then
              echo "Confirmed /etc/platform/env is present & available"
              sed -e 's/=.*/=<redacted>/' /etc/platform/env
            else
              echo "ERROR: /etc/platform/env missing"; exit 1
            fi
            
            # Build env file with IMAGE_TAG for app rollout
            echo "IMAGE_TAG=$SHA_TAG" > .env.runtime
            echo "Wrote .env.runtime:"
            sed -e 's/=.*/=<redacted>/' .env.runtime | sed 's/IMAGE_TAG=<redacted>/IMAGE_TAG='"$SHA_TAG"'/'
            
            # --- NEW: Ensure/refresh INFRA profile every deploy ---
            echo "Bringing up '${{ env.INFRA_PROFILE }}' profile (pull + up -d)"
            docker compose \
              --env-file /etc/platform/env --env-file ./.env.runtime \
              --profile "${{ env.INFRA_PROFILE }}" pull

            docker compose \
              --env-file /etc/platform/env --env-file ./.env.runtime \
              --profile "${{ env.INFRA_PROFILE }}" up -d --wait
            
            # --- Rollout APP profile services ---
            # Make both profiles visible so depends_on entries exist:
            export COMPOSE_PROFILES="infra,app"
            
            if docker rollout --help >/dev/null 2>&1; then
              echo "Using docker-rollout for app services"
            
              docker rollout -f docker-compose.yml \
                --env-file /etc/platform/env --env-file ./.env.runtime \
                --pre-stop-hook "sh -c 'touch /tmp/drain && sleep 30'" \
                api
            
              docker rollout -f docker-compose.yml \
                --env-file /etc/platform/env --env-file ./.env.runtime \
                --pre-stop-hook "sh -c 'touch /tmp/drain && sleep 20'" \
                web
            else
              echo "docker-rollout not found; using docker compose fallback for app profile"
            
              # Make sure both profiles are enabled for parsing, but only bring up app services:
              COMPOSE_PROFILES="infra,app" docker compose \
                --env-file /etc/platform/env --env-file ./.env.runtime \
                pull
            
              COMPOSE_PROFILES="infra,app" docker compose \
                --env-file /etc/platform/env --env-file ./.env.runtime \
                up -d api
            
              COMPOSE_PROFILES="infra,app" docker compose \
                --env-file /etc/platform/env --env-file ./.env.runtime \
                up -d web
            
              # Optional background
              if grep -qE '^[[:space:]]*background:' docker-compose.yml; then
                COMPOSE_PROFILES="infra,app" docker compose \
                  --env-file /etc/platform/env --env-file ./.env.runtime \
                  up -d background
              fi
            fi 

            # Clean up dangling layers
            docker compose --env-file /etc/platform/env --env-file ./.env.runtime --profile infra restart traefik && \
            docker image prune -f || true
            
            echo "ðŸš€ Deployment complete @ ${SHA_TAG}"