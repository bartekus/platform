name: Build and Push Docker Images

on:
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  SERVICES_TO_PUSH: web,background

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta (tags for all images)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix=,suffix=,format=short

      # Build/push non-API services with buildx (web,background)
      - name: Build & push generic services (non-API)
        run: |
          set -Eeuo pipefail
          IFS=',' read -ra SERVICES <<< "${SERVICES_TO_PUSH}"
          for svc in "${SERVICES[@]}"; do
            echo "==> $svc"
            docker buildx build \
              --file "./services/${svc}/Dockerfile" \
              --context "." \
              --tag "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${svc}:latest" \
              --tag "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${svc}:${{ steps.meta.outputs.sha }}" \
              --cache-from "type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${svc}:buildcache" \
              --cache-to   "type=registry,mode=max,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${svc}:buildcache" \
              --push
          done

      # Read encore.dev version from package.json and normalize to "vX.Y.Z"
      - name: Resolve Encore CLI version from package.json
        id: encorever
        run: |
          set -Eeuo pipefail
          RAW=$(jq -r '.dependencies["encore.dev"] // empty' package.json)
          [ -n "$RAW" ] && [ "$RAW" != "null" ] || { echo "encore.dev dep missing"; exit 1; }

#          if [ -z "${RAW}" ] || [ "${RAW}" = "null" ]; then
#            echo "encore.dev not found in dependencies" >&2
#            exit 1
#          fi

          CLEAN=$(printf "%s" "${RAW}" | sed 's/^[^0-9]*//')
          echo "version=v${CLEAN}" >> "$GITHUB_OUTPUT"

      # --- Encore API build & push ---
      - name: Install Encore CLI (pinned from package.json)
        env:
          ENCORE_VERSION: ${{ steps.encorever.outputs.version }}
        run: |
          set -Eeuo pipefail
          curl -fsSL https://encore.dev/install.sh -o install.sh
          bash install.sh
          /home/runner/.encore/bin/encore version

      - name: Verify Encore version
        run: |
          set -Eeuo pipefail
          WANT='${{ steps.encorever.outputs.version }}'
          GOT=$(/home/runner/.encore/bin/encore version | awk '{print $NF}')
          echo "Encore want=${WANT} got=${GOT}"
          test "${WANT}" = "${GOT}"

      - name: Build API image via Encore
        working-directory: backend
        env:
          # If you need a specific platform on runner, set it here:
          DOCKER_DEFAULT_PLATFORM: linux/amd64
        run: |
          set -Eeuo pipefail
          # Build local docker image named "encore-app" (Encore's default tag for docker builds)
          /home/runner/.encore/bin/encore build docker encore-app
          docker image inspect encore-app >/dev/null

      - name: Tag & push API image to GHCR (latest + sha)
        run: |
          set -Eeuo pipefail
          SHA_TAG="${{ steps.meta.outputs.sha }}"
          docker tag encore-app ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest
          docker tag encore-app ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${SHA_TAG}
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${SHA_TAG}

      # --- Materialize deployment artifacts from secrets ---
      - name: Prepare deployment artifacts from secrets
        run: |
          set -Eeuo pipefail
          mkdir -p .deploy/logto

          # 1) .env from ENV_FILE secret (verbatim)
          cat > .deploy/env <<'EOF'
          ${{ secrets.ENV_FILE }}
          EOF
          
          # 2) Postgres init script
          cat > .deploy/pg-init.sh <<'EOF'
          ${{ secrets.PG_INIT_SCRIPT }}
          EOF
          chmod +x .deploy/pg-init.sh
          
          # 3) Logto custom setup files
          cat > .deploy/logto/config.js <<'EOF'
          ${{ secrets.LOGTO_CONFIG }}
          EOF
          
          cat > .deploy/logto/entrypoint.sh <<'EOF'
          ${{ secrets.LOGTO_ENTRYPOINT }}
          EOF
          chmod +x .deploy/logto/entrypoint.sh
          
          cat > .deploy/logto/index.js <<'EOF'
          ${{ secrets.LOGTO_INDEX }}
          EOF
          
          cat > .deploy/logto/setup.js <<'EOF'
          ${{ secrets.LOGTO_SETUP }}
          EOF
          
          ls -lah .deploy .deploy/logto

      - name: Copy deployment artifacts and compose file to remote
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USER }}
          key: ${{ secrets.SSH_KEY }}
          # known_hosts: ${{ secrets.SSH_KNOWN_HOSTS }}   # â† enable if you store host key
          source: ".deploy/env,.deploy/pg-init.sh,.deploy/logto/*,docker-compose-deploy.yml"
          target: "/tmp"

      - name: Place artifacts into FHS paths and set permissions
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            set -Eeuo pipefail
            
            # Create FHS directories
            sudo mkdir -p /etc/platform
            sudo mkdir -p /opt/platform/scripts/db/pg-init-scripts
            sudo mkdir -p /opt/platform/scripts/logto
            sudo mkdir -p /opt/platform
            sudo mkdir -p /var/lib/platform/{postgres,redis,letsencrypt}
            
            # Move config/env
            sudo mv /tmp/env /etc/platform/env
            sudo chown root:root /etc/platform/env
            sudo chmod 600 /etc/platform/env
            
            # Move compose
            sudo mv /tmp/docker-compose-deploy.yml /opt/platform/docker-compose.yml
            sudo chown ${{ secrets.USER }}:${{ secrets.USER }} /opt/platform/docker-compose.yml
            sudo chmod 644 /opt/platform/docker-compose.yml
            
            # PG init scripts
            sudo mv /tmp/pg-init.sh /opt/platform/scripts/db/pg-init.sh
            sudo chown -R ${{ secrets.USER }}:${{ secrets.USER }} /opt/platform/scripts
            sudo chmod +x /opt/platform/scripts/db/pg-init.sh
            
            # Logto custom files
            sudo mv /tmp/config.js     /opt/platform/scripts/logto/config.js
            sudo mv /tmp/entrypoint.sh /opt/platform/scripts/logto/entrypoint.sh
            sudo mv /tmp/index.js      /opt/platform/scripts/logto/index.js
            sudo mv /tmp/setup.js      /opt/platform/scripts/logto/setup.js
            sudo chmod 755 /opt/platform/scripts/logto
            sudo chmod 644 /opt/platform/scripts/logto/*.js
            sudo chmod +x  /opt/platform/scripts/logto/entrypoint.sh
            

      - name: Deploy with rollout (immutable tag + draining)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USER }}
          key: ${{ secrets.SSH_KEY }}
          script_stop: true
          script: |
            set -Eeuo pipefail
            cd /opt/platform
            
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Ensure docker-rollout is available
            if ! docker rollout --help >/dev/null 2>&1; then
              echo "docker-rollout CLI not found. Run your vm_init or install the plugin." >&2
              exit 1
            fi
            
            # Pull immutable SHA tags for services
            IFS=',' read -ra SERVICES <<< "${{ env.SERVICES_TO_PUSH }}"
            SHA_TAG="${{ steps.meta.outputs.sha }}"
            for service in "${SERVICES[@]}"; do
              docker pull "ghcr.io/${{ env.IMAGE_NAME }}/${service}:${SHA_TAG}"
            done
            docker pull "ghcr.io/${{ env.IMAGE_NAME }}/api:${SHA_TAG}"
            
            # Export tag for compose
            echo "IMAGE_TAG=${SHA_TAG}" > .deploy.env
            
            # Drain-aware rollout for API and WEB; simple for BACKGROUND
            docker rollout -f docker-compose.yml --env-file .deploy.env \
              --pre-stop-hook "sh -c 'touch /tmp/drain && sleep 30'" api
            
            docker rollout -f docker-compose.yml --env-file .deploy.env \
              --pre-stop-hook "sh -c 'touch /tmp/drain && sleep 20'" web
            
            docker rollout -f docker-compose.yml --env-file .deploy.env background
            
            # Clean up dangling images only
            docker image prune -f
            
            echo "ðŸš€ Deployment complete @ ${SHA_TAG}"