name: Build and Push Docker Images

on:
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }} # owner/repo
  # IMPORTANT: exclude api here; we will build it via Encore separately
  SERVICES_TO_PUSH: web,background

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta (tags for all images)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix=,suffix=,format=short

      # Build/push non-API services with buildx (web,background)
      - name: Build & push generic services (non-API)
        run: |
          set -Eeuo pipefail
          IFS=',' read -ra SERVICES <<< "${SERVICES_TO_PUSH}"
          for svc in "${SERVICES[@]}"; do
            echo "==> $svc"
            docker buildx build \
              --file "./services/${svc}/Dockerfile" \
              --context "." \
              --tag "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${svc}:latest" \
              --tag "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${svc}:${{ steps.meta.outputs.sha }}" \
              --cache-from "type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${svc}:buildcache" \
              --cache-to   "type=registry,mode=max,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${svc}:buildcache" \
              --push
          done

      # Read encore.dev version from package.json and normalize to "vX.Y.Z"
      - name: Resolve Encore CLI version from package.json
        id: encorever
        run: |
          set -Eeuo pipefail
          RAW=$(jq -r '.dependencies["encore.dev"] // empty' package.json)
          if [ -z "${RAW}" ] || [ "${RAW}" = "null" ]; then
            echo "encore.dev not found in dependencies" >&2
            exit 1
          fi
          # strip leading non-digits (^, ~, >=, etc.)
          CLEAN=$(printf "%s" "${RAW}" | sed 's/^[^0-9]*//')
          if ! printf "%s" "${CLEAN}" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+'; then
            echo "Unable to parse encore.dev version: ${RAW}" >&2
            exit 1
          fi
          echo "version=v${CLEAN}" >> "$GITHUB_OUTPUT"

      # --- Encore API build & push ---
      - name: Install Encore CLI (pinned from package.json)
        env:
          ENCORE_VERSION: ${{ steps.encorever.outputs.version }}   # e.g., v1.50.0
        run: |
          set -Eeuo pipefail
          curl -fsSL https://encore.dev/install.sh -o install.sh
          bash install.sh
          /home/runner/.encore/bin/encore version

      - name: Verify Encore version
        run: |
          set -Eeuo pipefail
          WANT='${{ steps.encorever.outputs.version }}'
          GOT=$(/home/runner/.encore/bin/encore version | awk '{print $NF}')
          echo "Encore want=${WANT} got=${GOT}"
          test "${WANT}" = "${GOT}"

      - name: Build API image via Encore
        working-directory: backend
        env:
          # If you need a specific platform on runner, set it here:
          DOCKER_DEFAULT_PLATFORM: linux/amd64
        run: |
          set -Eeuo pipefail
          # Build local docker image named "encore-app" (Encore's default tag for docker builds)
          /home/runner/.encore/bin/encore build docker encore-app
          docker image inspect encore-app >/dev/null

      - name: Tag & push API image to GHCR (latest + sha)
        run: |
          set -Eeuo pipefail
          SHA_TAG="${{ steps.meta.outputs.sha }}"
          SRC="encore-app"
          LATEST="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest"
          IMMUT="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${SHA_TAG}"

          docker tag "$SRC" "$LATEST"
          docker tag "$SRC" "$IMMUT"
          docker push "$LATEST"
          docker push "$IMMUT"

      # --- Materialize deployment files from repo secrets ---
      - name: Prepare deployment artifacts from secrets
        run: |
          set -Eeuo pipefail
          mkdir -p .deploy/logto

          # 1) .env from ENV_FILE secret (verbatim)
          cat > .deploy/.env <<'EOF'
          ${{ secrets.ENV_FILE }}
          EOF
          
          # 2) Postgres init script
          cat > .deploy/pg-init.sh <<'EOF'
          ${{ secrets.PG_INIT_SCRIPT }}
          EOF
          chmod +x .deploy/pg-init.sh
          
          # 3) Logto custom setup files
          cat > .deploy/logto/config.js <<'EOF'
          ${{ secrets.LOGTO_CONFIG }}
          EOF
          
          cat > .deploy/logto/entrypoint.sh <<'EOF'
          ${{ secrets.LOGTO_ENTRYPOINT }}
          EOF
          chmod +x .deploy/logto/entrypoint.sh
          
          cat > .deploy/logto/index.js <<'EOF'
          ${{ secrets.LOGTO_INDEX }}
          EOF
          
          cat > .deploy/logto/setup.js <<'EOF'
          ${{ secrets.LOGTO_SETUP }}
          EOF
          
          ls -lah .deploy .deploy/logto

      - name: Copy deployment artifacts and compose file to remote
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USER }}
          key: ${{ secrets.SSH_KEY }}
          # known_hosts: ${{ secrets.SSH_KNOWN_HOSTS }}   # ← enable if you store host key
          source: ".deploy/.env,.deploy/pg-init.sh,.deploy/logto/*,docker-compose-deploy.yml"
          target: "/tmp"

      - name: Prepare Dozzle users.yml
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            set -Eeuo pipefail
            sudo mkdir -p /opt/dozzle/data
            printf '%s\n' "${{ secrets.DOZZLE_USER_YAML }}" | sudo tee /opt/dozzle/data/users.yml >/dev/null
            sudo chown -R ${{ secrets.USER }}:${{ secrets.USER }} /opt/dozzle
            sudo chmod 600 /opt/dozzle/data/users.yml

      - name: Move artifacts into place and set permissions
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            set -Eeuo pipefail
            sudo mkdir -p /opt /opt/scripts/db /opt/scripts/logto
            
            # Move .env and compose
            sudo mv /tmp/.env /opt/.env
            sudo mv /tmp/docker-compose-deploy.yml /opt/docker-compose.yml
            sudo chown ${{ secrets.USER }}:${{ secrets.USER }} /opt/.env /opt/docker-compose.yml
            sudo chmod 600 /opt/.env
            sudo chmod 644 /opt/docker-compose.yml
            
            # Move PG init
            sudo mv /tmp/pg-init.sh /opt/scripts/db/pg-init.sh
            sudo chown -R ${{ secrets.USER }}:${{ secrets.USER }} /opt/scripts/db
            sudo chmod +x /opt/scripts/db/pg-init.sh
            
            # Move Logto custom files
            sudo mv /tmp/config.js /opt/scripts/logto/config.js
            sudo mv /tmp/entrypoint.sh /opt/scripts/logto/entrypoint.sh
            sudo mv /tmp/index.js /opt/scripts/logto/index.js
            sudo mv /tmp/setup.js /opt/scripts/logto/setup.js
            sudo chown -R ${{ secrets.USER }}:${{ secrets.USER }} /opt/scripts/logto
            sudo chmod 755 /opt/scripts/logto
            sudo chmod 644 /opt/scripts/logto/*.js
            sudo chmod +x  /opt/scripts/logto/entrypoint.sh

      - name: Deploy with rollout (immutable tag + draining)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USER }}
          key: ${{ secrets.SSH_KEY }}
          script_stop: true
          script: |
            set -Eeuo pipefail
            
            cd /opt
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Ensure docker-rollout is available
            if ! docker rollout --help >/dev/null 2>&1; then
              echo "docker-rollout CLI not found. Run your vm_init or install the plugin." >&2
              exit 1
            fi
            
            # Pull immutable SHA tags for the services we’re deploying
            IFS=',' read -ra SERVICES <<< "${{ env.SERVICES_TO_PUSH }}"
            SHA_TAG="${{ steps.meta.outputs.sha }}"
            
            for service in "${SERVICES[@]}"; do
              docker pull "ghcr.io/${{ env.IMAGE_NAME }}/${service}:${SHA_TAG}"
            done
            
            # Export the tag for compose references
            echo "IMAGE_TAG=${SHA_TAG}" > .deploy.env
            
            # Drain-aware rollout for API and WEB; simple for BACKGROUND
            # Pre-stop hooks: touch drain file and sleep long enough for healthcheck->unhealthy + inflight completion
            docker rollout -f docker-compose.yml --env-file .deploy.env \
              --pre-stop-hook "sh -c 'touch /tmp/drain && sleep 30'" api
            
            docker rollout -f docker-compose.yml --env-file .deploy.env \
              --pre-stop-hook "sh -c 'touch /tmp/drain && sleep 20'" web
            
            docker rollout -f docker-compose.yml --env-file .deploy.env background
            
            # Clean up dangling images only
            docker image prune -f
            
            echo "🚀 Deployment complete @ ${SHA_TAG}"