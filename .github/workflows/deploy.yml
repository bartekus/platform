name: Build and Push

on:
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  SERVICES_TO_PUSH: web

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta (tags for all images)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix=,suffix=,format=short

      - name: Compute short SHA
        id: vars
        run: echo "short_sha=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"

      # Build/push non-API services with buildx (web,background)
      # Weâ€™ll point at your deploy compose file explicitly
      - name: Build & push (from docker-compose-deploy.yml with fallbacks)
        env:
          COMPOSE_FILE: docker-compose-deploy.yml
          SHORT_SHA: ${{ steps.vars.outputs.short_sha }}
        shell: python
        run: |
          import os, sys, subprocess, yaml
          
          REGISTRY = os.environ["REGISTRY"]
          IMAGE_NAME = os.environ["IMAGE_NAME"]       # e.g. bartekus/platform
          SERVICES_TO_PUSH = [s.strip() for s in os.environ["SERVICES_TO_PUSH"].split(",") if s.strip()]
          COMPOSE_FILE = os.environ.get("COMPOSE_FILE", "docker-compose.yml")
          SHORT_SHA = os.environ["SHORT_SHA"]
          
          # Conventional fallbacks when compose has no build: blocks
          FALLBACKS = {
            "web":  {"context": "frontend", "dockerfile": "Dockerfile"},
            "api":  {"context": "backend",  "dockerfile": "Dockerfile"},
            # "background": {"context": "background", "dockerfile": "Dockerfile"},
          }
          
          def sh(cmd, **kw):
            print("+", " ".join(cmd))
            subprocess.check_call(cmd, **kw)
          
          # Load compose (if present)
          compose = {}
          if os.path.exists(COMPOSE_FILE):
            with open(COMPOSE_FILE, "r") as f:
              compose = yaml.safe_load(f) or {}
          services_cfg = (compose.get("services") or {}) if isinstance(compose, dict) else {}
          
          for svc in SERVICES_TO_PUSH:
            print(f"==> {svc}")
            # Derive context/dockerfile
            context = None
            dockerfile = None
          
            if svc in services_cfg and isinstance(services_cfg[svc], dict) and "build" in services_cfg[svc]:
              b = services_cfg[svc]["build"]
              if isinstance(b, str):
                context = b
                dockerfile = os.path.join(context, "Dockerfile")
              elif isinstance(b, dict):
                context = b.get("context", ".")
                df = b.get("dockerfile", "Dockerfile")
                dockerfile = df if os.path.isabs(df) else os.path.join(context, df)
          
            # Fallbacks when no build info in compose
            if context is None or dockerfile is None:
              fb = FALLBACKS.get(svc)
              if not fb:
                print(f"Warning: No build info for '{svc}' and no fallback mapping. Skipping.")
                continue
              context = fb["context"]
              dockerfile = os.path.join(context, fb["dockerfile"])
          
            # Validate paths
            if not os.path.isdir(context):
              print(f"Error: context directory not found: {context}", file=sys.stderr)
              sys.exit(1)
            if not os.path.isfile(dockerfile):
              print(f"Error: Dockerfile not found: {dockerfile}", file=sys.stderr)
              sys.exit(1)
          
            repo = f"{REGISTRY}/{IMAGE_NAME}/{svc}"
            latest_tag = f"{repo}:latest"
            sha_tag = f"{repo}:{SHORT_SHA}"
            cache_ref = f"{repo}:buildcache"
          
            cmd = [
              "docker","buildx","build",
              "--file", dockerfile,
              "--tag", latest_tag,
              "--tag", sha_tag,
              "--cache-from", f"type=registry,ref={cache_ref}",
              "--cache-to",   f"type=registry,mode=max,ref={cache_ref}",
              "--push",
              context
            ]
            # Add plain progress if you want verbose output:
            # cmd.insert(5, "--progress=plain")
            sh(cmd)
          
          print("âœ… Done building & pushing:", ", ".join(SERVICES_TO_PUSH))

      # Read encore.dev version from package.json and normalize to "vX.Y.Z"
      - name: Resolve Encore CLI version from package.json
        id: encorever
        run: |
          set -Eeuo pipefail
          RAW=$(jq -r '.dependencies["encore.dev"] // empty' package.json)
          [ -n "$RAW" ] && [ "$RAW" != "null" ] || { echo "encore.dev dep missing"; exit 1; }
          CLEAN=$(printf "%s" "${RAW}" | sed 's/^[^0-9]*//')
          echo "version=v${CLEAN}" >> "$GITHUB_OUTPUT"

      - name: Set up Node (for Encore parser)
        uses: actions/setup-node@v4
        with:
          node-version: '22'                # match your frontend
          cache: 'npm'
          cache-dependency-path: |
            frontend/package-lock.json
            backend/package-lock.json

      - name: Install JS deps needed for parsing
        run: |
          set -Eeuo pipefail
          if [ -f frontend/package-lock.json ]; then
            npm ci --prefix frontend
          fi
          # If your backend has a package.json used by encore.ts runtime, keep this:
          if [ -f backend/package-lock.json ]; then
            npm ci --prefix backend
          fi

      # --- Encore API build & push ---
      - name: Install Encore CLI (pinned from package.json)
        env:
          ENCORE_VERSION: ${{ steps.encorever.outputs.version }}
        run: |
          set -Eeuo pipefail
          curl -fsSL https://encore.dev/install.sh -o install.sh
          bash install.sh
          /home/runner/.encore/bin/encore version

      - name: Verify Encore version
        run: |
          set -Eeuo pipefail
          WANT='${{ steps.encorever.outputs.version }}'
          GOT=$(/home/runner/.encore/bin/encore version | awk '{print $NF}')
          echo "Encore want=${WANT} got=${GOT}"
          test "${WANT}" = "${GOT}"

      - name: Build API image via Encore (from repo root)
        env:
          DOCKER_DEFAULT_PLATFORM: linux/amd64
        run: |
          set -Eeuo pipefail
          test -f ./encore-config.json || { echo "encore-config.json missing at repo root"; exit 1; }
          test -f ./encore.app || { echo "encore.app missing at repo root"; exit 1; }
          /home/runner/.encore/bin/encore build docker \
            --config ./encore-config.json \
            encore-app
          docker image inspect encore-app >/dev/null

      - name: Tag & push API image to GHCR (latest + sha)
        run: |
          set -Eeuo pipefail
          # Prefer our computed short SHA; fall back to first 7 of GITHUB_SHA.
          SHA_TAG="${{ steps.vars.outputs.short_sha }}"
          if [ -z "$SHA_TAG" ]; then
            SHA_TAG="$(echo "${GITHUB_SHA}" | cut -c1-7)"
          fi
          echo "Using SHA_TAG=$SHA_TAG"
          
          docker tag encore-app ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest
          docker tag encore-app ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${SHA_TAG}
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${SHA_TAG}

      - name: Print target host (sanity)
        run: |
          echo "Target host: ${{ vars.HOST }}"
          echo "Target user: ${{ vars.USER }}"

      # --- Materialize deployment artifacts from secrets ---
      - name: Prepare deployment artifacts from secrets
        run: |
          set -Eeuo pipefail
          mkdir -p .deploy/logto

          # 1) .env from ENV_FILE secret (verbatim)
          cat > .deploy/env <<'EOF'
          ${{ secrets.ENV_FILE }}
          EOF
          
          # 2) Postgres init script
          cat > .deploy/pg-init.sh <<'EOF'
          ${{ secrets.PG_INIT_SCRIPT }}
          EOF
          chmod +x .deploy/pg-init.sh
          
          # 3) Logto custom setup files
          cat > .deploy/logto/config.js <<'EOF'
          ${{ secrets.LOGTO_CONFIG }}
          EOF
          
          cat > .deploy/logto/entrypoint.sh <<'EOF'
          ${{ secrets.LOGTO_ENTRYPOINT }}
          EOF
          chmod +x .deploy/logto/entrypoint.sh
          
          cat > .deploy/logto/index.js <<'EOF'
          ${{ secrets.LOGTO_INDEX }}
          EOF
          
          cat > .deploy/logto/setup.js <<'EOF'
          ${{ secrets.LOGTO_SETUP }}
          EOF
          
          ls -lah .deploy .deploy/logto

      - name: Copy deployment artifacts and compose file to remote
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USER }}
          key: ${{ secrets.SSH_KEY }}
          target: "/tmp/platform-bundle"
          source: |
            .deploy/env
            .deploy/pg-init.sh
            .deploy/logto/config.js
            .deploy/logto/entrypoint.sh
            .deploy/logto/index.js
            .deploy/logto/setup.js
            docker-compose-deploy.yml

      - name: Place artifacts into FHS paths and set permissions
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            set -Eeuo pipefail
            
            SRC="/tmp/platform-bundle"
            
            echo "Contents of ${SRC}:"
            ls -lah "${SRC}" || true
            ls -lah "${SRC}/.deploy" || true
            ls -lah "${SRC}/.deploy/logto" || true
            
            # Create FHS directories (avoid brace expansion quirks)
            sudo mkdir -p /etc/platform
            sudo mkdir -p /opt/platform/scripts/db/pg-init-scripts
            sudo mkdir -p /opt/platform/scripts/logto
            sudo mkdir -p /opt/platform
            sudo mkdir -p /var/lib/platform/postgres /var/lib/platform/redis /var/lib/platform/letsencrypt
            
            # Validate expected files before moving
            for f in "${SRC}/.deploy/env" \
                     "${SRC}/.deploy/pg-init.sh" \
                     "${SRC}/.deploy/logto/config.js" \
                     "${SRC}/.deploy/logto/entrypoint.sh" \
                     "${SRC}/.deploy/logto/index.js" \
                     "${SRC}/.deploy/logto/setup.js" \
                     "${SRC}/docker-compose-deploy.yml"; do
              [ -f "$f" ] || { echo "Missing: $f"; exit 1; }
            done
            
            # Move config/env
            sudo mv "${SRC}/.deploy/env" /etc/platform/env
            sudo chown root:root /etc/platform/env
            sudo chmod 600 /etc/platform/env
            
            # Move compose
            sudo mv "${SRC}/docker-compose-deploy.yml" /opt/platform/docker-compose.yml
            # If you want a non-root owner for compose, change owner here:
            sudo chown root:root /opt/platform/docker-compose.yml
            sudo chmod 644 /opt/platform/docker-compose.yml
            
            # PG init scripts
            sudo mv "${SRC}/.deploy/pg-init.sh" /opt/platform/scripts/db/pg-init.sh
            sudo chown -R root:root /opt/platform/scripts
            sudo chmod +x /opt/platform/scripts/db/pg-init.sh
            
            # Logto custom files
            sudo mv "${SRC}/.deploy/logto/config.js"     /opt/platform/scripts/logto/config.js
            sudo mv "${SRC}/.deploy/logto/entrypoint.sh" /opt/platform/scripts/logto/entrypoint.sh
            sudo mv "${SRC}/.deploy/logto/index.js"      /opt/platform/scripts/logto/index.js
            sudo mv "${SRC}/.deploy/logto/setup.js"      /opt/platform/scripts/logto/setup.js
            sudo chmod 755 /opt/platform/scripts/logto
            sudo chmod 644 /opt/platform/scripts/logto/*.js
            sudo chmod +x  /opt/platform/scripts/logto/entrypoint.sh
            
            echo "File placement completed."


      - name: Deploy with rollout (immutable tag + draining)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USER }}
          key: ${{ secrets.SSH_KEY }}
          script_stop: true
          script: |
            set -Eeuo pipefail
            cd /opt/platform
            
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Ensure docker-rollout is available
            if ! docker rollout --help >/dev/null 2>&1; then
              echo "docker-rollout CLI not found. Run your vm_init or install the plugin." >&2
              exit 1
            fi
            
            # Pull immutable SHA tags for services
            IFS=',' read -ra SERVICES <<< "${{ env.SERVICES_TO_PUSH }}"
            SHA_TAG="${{ steps.meta.outputs.sha }}"
            for service in "${SERVICES[@]}"; do
              docker pull "ghcr.io/${{ env.IMAGE_NAME }}/${service}:${SHA_TAG}"
            done
            docker pull "ghcr.io/${{ env.IMAGE_NAME }}/api:${SHA_TAG}"
            
            # Export tag for compose
            echo "IMAGE_TAG=${SHA_TAG}" > .deploy.env
            
            # Drain-aware rollout for API and WEB; simple for BACKGROUND
            docker rollout -f docker-compose.yml --env-file .deploy.env \
              --pre-stop-hook "sh -c 'touch /tmp/drain && sleep 30'" api
            
            docker rollout -f docker-compose.yml --env-file .deploy.env \
              --pre-stop-hook "sh -c 'touch /tmp/drain && sleep 20'" web
            
            docker rollout -f docker-compose.yml --env-file .deploy.env background
            
            # Clean up dangling images only
            docker image prune -f
            
            echo "ðŸš€ Deployment complete @ ${SHA_TAG}"