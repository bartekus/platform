name: Build and Push

on:
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  SERVICES_TO_PUSH: web

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta (tags for all images)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix=,suffix=,format=short

      - name: Compute short SHA
        id: vars
        run: echo "short_sha=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"

      # Build/push non-API services with buildx (web,background)
      - name: Build & push (compose-aware, bash+jq)
        env:
          COMPOSE_FILE: docker-compose-deploy.yml
          SHORT_SHA: ${{ steps.vars.outputs.short_sha }}
        run: |
          set -Eeuo pipefail
          
          # services we want to build (comma-separated), e.g. "web" or "web,background"
          IFS=',' read -ra SERVICES <<< "${SERVICES_TO_PUSH}"
          
          # Generate normalized compose as JSON (handles anchors/extends/etc.)
          if [[ ! -f "${COMPOSE_FILE}" ]]; then
            echo "❌ compose file not found: ${COMPOSE_FILE}" >&2
            exit 1
          fi
          CONFIG_JSON="$(docker compose -f "${COMPOSE_FILE}" config --format json)"
          
          # Helper to pull build info (context/dockerfile) from compose (string OR object)
          get_build_info() {
            local svc="$1"
            jq -r --arg s "$svc" '
              if .services[$s] and .services[$s].build then
                ( .services[$s].build | 
                  if type=="string" then 
                    {context: ., dockerfile: "Dockerfile"} 
                  else 
                    {context: (.context // "."), dockerfile: (.dockerfile // "Dockerfile")} 
                  end )
              else empty end
            ' <<<"$CONFIG_JSON"
          }
          
          for svc in "${SERVICES[@]}"; do
            echo "==> ${svc}"
            context="" ; dockerfile=""
          
            # Try compose build block first
            BI="$(get_build_info "$svc")"
            if [[ -n "$BI" && "$BI" != "null" ]]; then
              context="$(jq -r '.context' <<<"$BI")"
              dockerfile="$(jq -r '.dockerfile' <<<"$BI")"
            else
              # Fallbacks when compose has only image: (no build:)
              case "$svc" in
                web) context="frontend"; dockerfile="Dockerfile" ;;
                background) context="background"; dockerfile="Dockerfile" ;;
                *)
                  echo "⚠️  No build info for '${svc}' and no fallback mapping. Skipping."
                  continue
                ;;
              esac
            fi
          
            # If dockerfile is relative, make it relative to context
            if [[ "$dockerfile" != /* ]]; then
              dockerfile="${context%/}/${dockerfile}"
            fi
          
            # Validate paths
            [[ -d "$context" ]]    || { echo "❌ context dir not found: $context" >&2; exit 1; }
            [[ -f "$dockerfile" ]] || { echo "❌ Dockerfile not found: $dockerfile" >&2; exit 1; }
          
            repo="${REGISTRY}/${IMAGE_NAME}/${svc}"
            latest_tag="${repo}:latest"
            sha_tag="${repo}:${SHORT_SHA}"
            cache_ref="${repo}:buildcache"
          
            echo "Context:    $context"
            echo "Dockerfile: $dockerfile"
            echo "Tags:       $latest_tag , $sha_tag"
          
            docker buildx build \
              --file "$dockerfile" \
              --tag "$latest_tag" \
              --tag "$sha_tag" \
              --cache-from "type=registry,ref=${cache_ref}" \
              --cache-to   "type=registry,mode=max,ref=${cache_ref}" \
              --push \
              "$context"
          done

      # Read encore.dev version from package.json and normalize to "vX.Y.Z"
      - name: Resolve Encore CLI version from package.json
        id: encorever
        run: |
          set -Eeuo pipefail
          RAW=$(jq -r '.dependencies["encore.dev"] // empty' package.json)
          [ -n "$RAW" ] && [ "$RAW" != "null" ] || { echo "encore.dev dep missing"; exit 1; }
          CLEAN=$(printf "%s" "${RAW}" | sed 's/^[^0-9]*//')
          echo "version=v${CLEAN}" >> "$GITHUB_OUTPUT"

      # --- Encore API build & push ---
      - name: Install Encore CLI (pinned from package.json)
        env:
          ENCORE_VERSION: ${{ steps.encorever.outputs.version }}
        run: |
          set -Eeuo pipefail
          curl -fsSL https://encore.dev/install.sh -o install.sh
          bash install.sh
          /home/runner/.encore/bin/encore version

      - name: Verify Encore version
        run: |
          set -Eeuo pipefail
          WANT='${{ steps.encorever.outputs.version }}'
          GOT=$(/home/runner/.encore/bin/encore version | awk '{print $NF}')
          echo "Encore want=${WANT} got=${GOT}"
          test "${WANT}" = "${GOT}"

      - name: Build API image via Encore
        working-directory: backend
        env:
          # If you need a specific platform on runner, set it here:
          DOCKER_DEFAULT_PLATFORM: linux/amd64
        run: |
          set -Eeuo pipefail
          # Build local docker image named "encore-app" (Encore's default tag for docker builds)
          /home/runner/.encore/bin/encore build docker encore-app
          docker image inspect encore-app >/dev/null

      - name: Tag & push API image to GHCR (latest + sha)
        run: |
          set -Eeuo pipefail
          SHA_TAG="${{ steps.meta.outputs.sha }}"
          docker tag encore-app ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest
          docker tag encore-app ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${SHA_TAG}
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${SHA_TAG}

      - name: Print target host (sanity)
        run: |
          echo "Target host: ${{ vars.HOST }}"
          echo "Target user: ${{ vars.USER }}"

      # --- Materialize deployment artifacts from secrets ---
      - name: Prepare deployment artifacts from secrets
        run: |
          set -Eeuo pipefail
          mkdir -p .deploy/logto

          # 1) .env from ENV_FILE secret (verbatim)
          cat > .deploy/env <<'EOF'
          ${{ secrets.ENV_FILE }}
          EOF
          
          # 2) Postgres init script
          cat > .deploy/pg-init.sh <<'EOF'
          ${{ secrets.PG_INIT_SCRIPT }}
          EOF
          chmod +x .deploy/pg-init.sh
          
          # 3) Logto custom setup files
          cat > .deploy/logto/config.js <<'EOF'
          ${{ secrets.LOGTO_CONFIG }}
          EOF
          
          cat > .deploy/logto/entrypoint.sh <<'EOF'
          ${{ secrets.LOGTO_ENTRYPOINT }}
          EOF
          chmod +x .deploy/logto/entrypoint.sh
          
          cat > .deploy/logto/index.js <<'EOF'
          ${{ secrets.LOGTO_INDEX }}
          EOF
          
          cat > .deploy/logto/setup.js <<'EOF'
          ${{ secrets.LOGTO_SETUP }}
          EOF
          
          ls -lah .deploy .deploy/logto

      - name: Copy deployment artifacts and compose file to remote
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USER }}
          key: ${{ secrets.SSH_KEY }}
          # known_hosts: ${{ secrets.SSH_KNOWN_HOSTS }}   # ← enable if you store host key
          source: ".deploy/env,.deploy/pg-init.sh,.deploy/logto/*,docker-compose-deploy.yml"
          target: "/tmp"

      - name: Place artifacts into FHS paths and set permissions
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            set -Eeuo pipefail
            
            # Create FHS directories
            sudo mkdir -p /etc/platform
            sudo mkdir -p /opt/platform/scripts/db/pg-init-scripts
            sudo mkdir -p /opt/platform/scripts/logto
            sudo mkdir -p /opt/platform
            sudo mkdir -p /var/lib/platform/{postgres,redis,letsencrypt}
            
            # Move config/env
            sudo mv /tmp/env /etc/platform/env
            sudo chown root:root /etc/platform/env
            sudo chmod 600 /etc/platform/env
            
            # Move compose
            sudo mv /tmp/docker-compose-deploy.yml /opt/platform/docker-compose.yml
            sudo chown ${{ vars.USER }}:${{ vars.USER }} /opt/platform/docker-compose.yml
            sudo chmod 644 /opt/platform/docker-compose.yml
            
            # PG init scripts
            sudo mv /tmp/pg-init.sh /opt/platform/scripts/db/pg-init.sh
            sudo chown -R ${{ vars.USER }}:${{ vars.USER }} /opt/platform/scripts
            sudo chmod +x /opt/platform/scripts/db/pg-init.sh
            
            # Logto custom files
            sudo mv /tmp/config.js     /opt/platform/scripts/logto/config.js
            sudo mv /tmp/entrypoint.sh /opt/platform/scripts/logto/entrypoint.sh
            sudo mv /tmp/index.js      /opt/platform/scripts/logto/index.js
            sudo mv /tmp/setup.js      /opt/platform/scripts/logto/setup.js
            sudo chmod 755 /opt/platform/scripts/logto
            sudo chmod 644 /opt/platform/scripts/logto/*.js
            sudo chmod +x  /opt/platform/scripts/logto/entrypoint.sh


      - name: Deploy with rollout (immutable tag + draining)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USER }}
          key: ${{ secrets.SSH_KEY }}
          script_stop: true
          script: |
            set -Eeuo pipefail
            cd /opt/platform
            
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Ensure docker-rollout is available
            if ! docker rollout --help >/dev/null 2>&1; then
              echo "docker-rollout CLI not found. Run your vm_init or install the plugin." >&2
              exit 1
            fi
            
            # Pull immutable SHA tags for services
            IFS=',' read -ra SERVICES <<< "${{ env.SERVICES_TO_PUSH }}"
            SHA_TAG="${{ steps.meta.outputs.sha }}"
            for service in "${SERVICES[@]}"; do
              docker pull "ghcr.io/${{ env.IMAGE_NAME }}/${service}:${SHA_TAG}"
            done
            docker pull "ghcr.io/${{ env.IMAGE_NAME }}/api:${SHA_TAG}"
            
            # Export tag for compose
            echo "IMAGE_TAG=${SHA_TAG}" > .deploy.env
            
            # Drain-aware rollout for API and WEB; simple for BACKGROUND
            docker rollout -f docker-compose.yml --env-file .deploy.env \
              --pre-stop-hook "sh -c 'touch /tmp/drain && sleep 30'" api
            
            docker rollout -f docker-compose.yml --env-file .deploy.env \
              --pre-stop-hook "sh -c 'touch /tmp/drain && sleep 20'" web
            
            docker rollout -f docker-compose.yml --env-file .deploy.env background
            
            # Clean up dangling images only
            docker image prune -f
            
            echo "🚀 Deployment complete @ ${SHA_TAG}"